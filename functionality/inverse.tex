\section{Iterative workflow control}

\begin{figure}
  \includegraphics[width=0.7\columnwidth]{functionality/fig/flowchart.eps}
  \caption{
    \label{fig:flowchart}
    Block-scheme of the workflow control for the iterative methods. The most time-consuming parts are marked in red.
  }
\end{figure}

During the global initialization the initial guess for the coarse-grained potential is calculated from the reference radial distribution function or converted from a given potential guess to the internal format. The actual iterative step starts with an iteration initialization. It searches for possible checkpoints and copies and converts files from the previous step and the base directory. Then the simulation run is prepared by converting potentials to the format required by the external sampling program and the actual sampling is performed. Currently, an interface with \gromacs~\cite{gromacs4} is implemented but an extension for other packages is straightforward. After sampling the phasespace, the potential update $\Delta U$ is calculated. Often the update requires postprocessing, such as smoothing, interpolation, extrapolation or fitting to an analytical form. A simple pressure correction~\cite{Reith:2003} can also be seen as a postprocessing of $\Delta U$, due to the fact that it only adds a linear interparticle separation function.
%
Finally, the new potential is determined and postprocessed. If the iterative process continues, the next iterative step starts to initialize.

\subsection{General usage}
To setup the environment, run:
csh, tcsh:
\begin{verbatim}
  source <csg-installation>/bin/CSGRC.csh
\end{verbatim}
\begin{verbatim}
  bash: source <csg-installation>/bin/CSGRC.bash
\end{verbatim}
The program to run all iterative procedures is \prog{csg_inverse}. Tutorials can be found on the \votca homepage \votcaweb. 

\subsection{Run preparation}
To run the iterations, the input for the sampling program (e.g. \gromacs ) has to be prepared in order to carry out one iteration. All files for running a coarse-grained simulation except for the tabulated potentials that will be created during the run must be present and specified in the options xml-file.

As a target distribution, any table file can be given (e.g. gromacs output from g\_rdf). The program automaticaly takes care to resample the table to the correct grid spacing as specified in the .xml file.
The initial guess is created by inverting the tiven rdf. It is located in step\_000/$<$name$>$.pot.new. To specify the initial guess for a specific interaction by hand, write the potential table to a file called $<$name$>$.pot.in in the folder where you plan to run the iterative procedure.

To define which interactions are iteratively refined, a section for each has to be specified in the options file. A full list of parameters can be found in ref.~\ref{sec:ref_options}.

\subsection{Running the iterative process}
After all input files have been set up, the run can be started with
\begin{verbatim}
  csg_inverse <settings.xml>
\end{verbatim}

For each iteration, a separate directory (\textit{step\_$<$iteration$>$}) is created, where \textit{step\_000} has the special meaning of the initial setup before the first iterations. For each new iterations, the files required to run the CG simulation (as specified in the config file) are copied to the current working directory. Also the updated potentials from the last steps (step\_$<$n-1$>$/$<$interaction$>$.pot.new) are copied and used as the new working potentials (stetp\_$<$n$>$\/$<$interaction$>$.pot.cur).

After the preparation, all potentials are converted to the format of the sampling program and the simulation is started. As soon as the run is finished, analysis programs are started and new distributions ($<$interaction$>$.dist.new) as well as the update ($<$interaction$>$.dpot.new) are calculated. Before \votca adds the update to the old potential, the update can be processed in the post\_update step. For each script that is specified in post\_update, \votca renames $<$interaction$>$.dpot.new to $<$interaction$>$.dpot.old, stores it in $<$interaction$>$.dpot.$<$a-number$>$, and calls the processing script. Each processing script is supposed to take the current update ($<$interaction$>$.dpot.cur) and write the processed update ($<$interaction$>$.dpot.new). Pressure correction is implemented as a post\_update script within this framework.

After all post\_update scripts have been called, the update is added to the potential and the new potential ( $<$interaction$>$.pot.new ) is written. Furthermore, processing of the potential is performed in the post\_add step, analogous to the tasks performed in post\_update but now for the potential instead of the update.

In summary, the standard output files of \votca for each step are listed in the following table:

\begin{tabular}{ll}
*.dist.new & distribution functions of the current step \\
*.dpot.new & the final potential update, created by calc\_update \\
*.dpot.$<$number$>$ & for each post\_update script, the current .dpot.new is saved and a new one is created\\
*.pot.cur & the current potential, which the actual run was performed with \\
*.pot.new & the new potential after the add step \\
*.pot.$<$number$>$ & same as dpot.$<$number$>$ but for post\_add
\end{tabular}

If some sub-step within one iteration has failed, additional information can be found in the log file. The name of this log file can be specified in the options xml-file.

\subsection{Run continuation}
There are two scenarios when one wants to continue a run. Either, that of extending a finished run or that the run was interrupted and one needs to restart at the current point. When \prog{csg_inverse} is started, it automatically checks for a file called \textit{done} in the current directory. If it exists, the program assumes that the run is finished. To extend the run, simply increase \cgopt{inverse.iterations_max} in the settings file and remove the file called done. After that, csg\_inverse can be restarted, it will automatically recognize existing steps and continue after the last one.

If a run was interrupted, \prog{csg_inverse} might not be able to restart on its own. In this case, the easiest solution is just to delete the last step and start again. It will then redo the last step and continue. However, this method is not always practical since sampling and analysis might take a very long time and the run might have only crashed due to some bogus post processing option. To avoid redoing the entire run, \prog{csg_inverse} creates a file with restart points, which marks actions in the step that were already completed (like simulation, analysis, etc). The file is specified in the option \cgopt{inverse.restart_file}. If specific actions should be redone, lines in that file can also removed by hand. In addition, a file \textit{done} is created in each folder for a steps which have already been finished.

\subsection{Customization}
In principle, each sub-step of an iteration and all direct calls can be changed. 
All script is called via two keywords.
\begin{verbatim}
csg_call key1 key2
\end{verbatim} 
For example \texttt{csg\_call update imc} calls the update script for inverse monte carlo procedure.
The default keyword to script mapping can be seen in \sect{sec:csg_table} or seen directly by calling:
\begin{verbatim}
csg_call --list
\end{verbatim} 

Please {\em never} change the scripts in the \votca installation. It is better to copy the script to your script directory (defined by \cgopt{inverse.scriptdir}) and redirect its call by creating a own \texttt{csg\_table} in this directory with a contain like this:
\begin{verbatim}
key1 key2 script options
key3 key4 script2
\end{verbatim} 
One can even overload existing call.
\subsubsection{An useful example}
\prog{csg_inverse} runs \prog{mdrun} from the \gromacs package only on one cpu and we want to change that due to the fact that we have 8 cpu machine and want to save some time.
First we try to find out which script calls \prog{mdrun}:
\begin{verbatim}
csg_call --list | grep gromacs
\end{verbatim}
In this case we are lucky, the output is quite helpful:
\begin{verbatim}
init gromacs initalize_gromacs.sh
prepare gromacs prepare_gromacs.sh
run gromacs run_gromacs.sh
pressure gromacs calc_pressure_gromacs.sh
rdf gromacs calc_rdf_gromacs.sh
imc_stat gromacs imc_stat_generic.sh
convert_potential gromacs potential_to_gromacs.sh
functions gromacs functions_gromacs.sh
\end{verbatim}
the third entry sounds reasonable. If the output of \prog{csg_call} is not useful, one should try to find the right script in \sect{sec:csg_table}. If this doesn't help one has to go the $<$csg-installation$>$/share/scripts/inverse and find the script there. However in this case the output of:
\begin{verbatim}
csg_call --show run gromacs
\end{verbatim}
looks like we have found the right script:
\begin{verbatim}
#!/bin/bash
# Copyright 2009 The VOTCA Development Team (http://www.votca.org)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

if [ "$1" = "--help" ]; then
cat <<EOF
${0##*/}, version 1.0_rc1 hgid: 5553f40f6aafbc05449582c788fd5017c72c9b7b
This script runs gromacs
for the Inverse Boltzmann Method

Usage: ${0##*/}

USES: run_or_exit mdrun
EOF
   exit 0
fi

check_deps "$0"

run_or_exit mdrun
\end{verbatim}
Now we create our own scriptdir, add script there, make it executable and overload the call of the script:
\begin{verbatim}
mkdir -p SCRIPTDIR
csg_call --show run gromacs > SCRIPTDIR/MY_run_gromacs.sh
chmod 755 SCRIPTDIR/MY_run_gromacs.sh
echo "run gromacs MY_run_gromacs.sh" >> SCRIPTDIR/csg_table
\end{verbatim}
Please note that \texttt{MY\_run\_gromacs.sh} is the name of the script and \texttt{SCRIPTDIR} is the custom script directory, which can be a global or local path.
Now we change the last line of \texttt{MY\_run\_gromacs.sh} to:
\begin{verbatim}
run_or_exit mpirun -np 8 mdrun
\end{verbatim}
and that is it, please note that you should be remove the license infomations and change the version of the scipt to not end up in a big mess.
You can check your work by running:
\begin{verbatim}
csg_call --scriptdir SCRIPTDIR --list
csg_call --scriptdir SCRIPTDIR --show run gromacs
\end{verbatim}
and do not forget to add \texttt{SCRIPTDIR} to \cgopt{inverse.scriptdir} in setting \xml file (see \sect{sec:ref_options}).

