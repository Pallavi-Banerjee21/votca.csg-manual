\section{Iterative Inverse Boltzmann}
\begin{figure}
   \centering
   \includegraphics{usage/fig/flow_ibi.eps}
   \caption{\label{fig:flow_ibi}Flowchart to perform iterative Boltzmann inversion.}
\end{figure}

\subsection{Input preparation}
In this section, the usage of \ibi is described which is implemented within the scripting framework described in \sect{sec:impl:scripting}. It is suggested to get a basic understaning on the framework before proceeding.

Iterative inverse boltzmann so far only supports iterative refinement of non-bonded interactions. An outline of the workflow to perform \ibi is given in \fig{fig:flow_ibi}. The first thing to do is generate reference distribution functions. They might come from experiments or from atomistic simulations. To get a reasonable results out of the iterative process, the reference distributions should have a good quality (little noise, ...).

\votca can create initial guesses for the coarse-grained potentials by boltzmann inverting the distribution function. If a custom initial guess for an interaction should be used instead, the table can be provided in \textit{<interaction>.pot.in}. As just mentioned, \votca automatically create potential tables to run a simulation, however it does not know how to run a coarse-grained simulation. All files to run a coarse-grained simulation except for the potentials that are iteratively refined must be provided and added to the \hyperlink{\refopt{cg.inverse.filelist}}{filelist} in the option xml file. If an atomistic topology and a mapping definition is present, \votca offers tools to assist the setup of a  coarse-grined topology (see \sect{sec:usage:cgrun}).

To get an overview how an input file for doing \ibi looks like, a good start is to look at one of the tutorials provided on \votcaweb.

\subsection{Pressure correction}

The pressure of the coarse-grained system usually does not match the pressure of the full atomistic system. The reason is that during the itereative boltzmann inversion only structural properties and not thermodynamic properties are targeted.\\
In order correct the pressure to match the target pressure, different strategies have been used based on small modifications of the potential. The type of pressure correction is selected as described in section \sect{sec:ref_interaction}.

\subsubsection{Simple pressure correction}

In \cite{Reith:2003} a simple linear attractive potential was added to the coarse-grained potential:
\begin{equation}\Delta V(r)=A(1-\frac{r}{r_{cutoff}})\end{equation}
The correction can be applied after each step of the iterative boltzmann procedure by using the post\_update pressure option
The prefactor $A$ used in the iterative procedure is 
\begin{equation}-\operatorname{sgn}(\Delta P)0.1k_{B}T\min(1,|f\Delta P)\end{equation}
 with $\Delta p=P_i-P_{target}$. Where the scaling factor f is given by the scale variable in the input file:
\begin{verbatim}
  <post_update>pressure</post_update>
  <post_update_options>
    <pressure>
        <simple>
		<scale>0.0003</scale>
	</simple>
    </pressure
  </post_update_options>
\end{verbatim}
In order to get the correct pressure it can become necessary to tune the scaling factor $f$ during the iterative process.
\subsubsection{Wang-Junghans-Kremer pressure correction}

In \cite{Wang:2009} a pressure correction based on the virial expression of the pressure was introduced. The potential term is the same as in the simple form with a different form of the $A$ factor being used:
\begin{equation}\left[\frac{-2\pi\rho^{2}}{3r_{cut}}\int_{0}^{r_{cut}}r^{3}g_{i}(r)dr\right]A_{i}=\Delta P\end{equation}
This requires as an additional input parameter the particle density $ \rho $ to be provided, which is added as particle\_dens in the input file. 

\subsection{Runtime optimization}
Most of the time for each iteration is spent in running the coarse-grained system and calculate the statistics. To get a feeling on how much statistics really is needed, it is recommended to plot the distribution functions and check weather they are sufficiently smooth. Bad statistics lead to rough potential updates and the iterative refinement might fail. The runs should be long enough to produce distributions/rdfs with reasonable quality.

Often, runtime can be improved by smoothing the potential updates. Our experience has shown, that it is better to smooth the potential update instead of the rdf or potential itself. If the potential/rdf is smoothened, sharp features like the first peak in \spce water might get lost. Smoothing on the delta potential works quite well, since the sharp features are already present from the initial guess. By applying iterations of a simple triangular smooth ($ \Delta U_i = 0.25 \Delta U_{i-1} + 0.5\Delta U_i + 0.25\Delta U_{i+1} $), a reasonable coarse-grained potential for \spce water could be produced in less than 10 mins. Smoothing is implemented as a post\_update script and can be enabled by adding
\begin{verbatim}
  <post_update>smooth</post_update>
  <post_update_options>
    <smooth>
        <iterations>4</iterations>
    </smooth>
  </post_update_options>
\end{verbatim}
to the inverse section of an interaction in the options xml.



