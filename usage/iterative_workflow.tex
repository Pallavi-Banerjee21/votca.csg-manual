\chapter{Iterative workflow control}
\label{sec:iterative_workflow}

%\begin{figure}
\begin{wrapfigure}{ht}{7cm}  
\includegraphics[width=7cm]{functionality/fig/flowchart.eps}
  \caption{
    \label{fig:flowchart}
    Block-scheme of the workflow control for the iterative methods. The most time-consuming parts are marked in red.
  }
\end{wrapfigure}
%\end{figure}
Iterative workflow control is essential for the \ibi and \imc methods. Before using it, the \texttt{CSGSHARE} variable must be set. The \votca initialization script will do that for you (see sec.~\ref{sec:introduction} on how to source it.)

The general idea of iterative workflow is sketched in fig.~\ref{fig:flowchart}. During the global initialization the initial guess for the coarse-grained potential is calculated from the reference function or converted from a given potential guess into the internal format. The actual iterative step starts with an iteration initialization. It searches for possible checkpoints and copies and converts files from the previous step and the base directory. Then, the simulation run is prepared by converting potentials into the format required by the external sampling program and the actual sampling is performed. 

After sampling the phasespace, the potential update is calculated. Often, the update requires postprocessing, such as smoothing, interpolation, extrapolation or fitting to an analytical form. 
Finally, the new potential is determined and postprocessed. If the iterative process continues, the next iterative step will start to initialize.

In what follows we describe how to setup the iterative coarse-graining, run the main script, continue the run, and add customized scripts. 

\section{Preparing the run}
\label{sec:preparing_the_run}
To start the first iteration, one has to prepare the input for the sampling program. This means that all files for running a coarse-grained simulation must be present and described in a separate \xml file, in our case \texttt{settings.xml} (see sec. \ref{sec:setting_files} for details). An extract from this file is given below. The only exception are tabulated potentials, which will be created and updated by the script in the course of the iterative process.

The input files include: target distributions, initial guess (optional) and a list of interactions to be iteratively refined. As a target distribution, any table file can be given (e.g. \gromacs output from \texttt{g\_rdf}). The program automatically takes care to resample the table to the correct grid spacing according to the options provided in \texttt{settings.xml}.

The initial guess is normally taken as a potential of mean force and is generated by Boltzmann-inversion of the corresponding distribution function. It is written in \texttt{step\_000/<name>.pot.new}. If you want to manually specify the initial guess for a specific interaction, write the potential table to a file called \texttt{<name>.pot.in} in the folder where you plan to run the iterative procedure.

A list of interactions to be iteratively refined has to be given in the options file. As an example, the \texttt{setting.xml} file for a propane is shown in listing~\ref{list:settings}. For more details,  see the full description of all options in ref.~\ref{sec:ref_options}.
\begin{figure}
\centering
\framebox{
\lstinputlisting{functionality/settings.xml}
}
\caption{\texttt{settings.xml} file specifies interactions to be refined, grid spacings, sampling engine, and the iterative method. The complete file can be found in the \texttt{propane/ibm} tutorial. 
\label{list:settings}
}
\end{figure}

\section{Starting the iterative process}
\label{sec:starting_iterative_process}
After all input files have been set up, the run can be started with
\begin{verbatim}
  csg_inverse settings.xml
\end{verbatim}

Each iteration is stored in a separate directory, named \texttt{step\_<iteration>}. \texttt{step\_000} is a special folder which contains the initial setup. For each new iteration, the files required to run the CG simulation (as specified in the config file) are copied to the current working directory. The updated potentials  are copied from the last step, \texttt{step\_<n-1>/<interaction>.pot.new}, and used as the new working potentials \texttt{step\_<n>/<interaction>.pot.cur}.

After the run preparation, all potentials are converted into the format of the sampling program and the simulation starts. Once the sampling has finished, analysis programs generate new distributions, which are stored in \texttt{<interaction>.dist.new}, and new potential updates, stored in \texttt{<interaction>.dpot.new}. 

Before adding the update to the old potential, it can be processed in the \texttt{post\_update} step. For each script that is specified in the postupdate, \texttt{<interaction>.dpot.new} is renamed  to \texttt{<interaction>.dpot.old} and stored in \texttt{<interaction>.dpot.<a-number>} before the processing script is called. Each processing script  uses the current potential update \texttt{<interaction>.dpot.cur} and writes the processed update to \texttt{<interaction>.dpot.new}. As an example, a pressure correction is implemented as a postupdate script within this framework.

After all postupdate scripts have been called, the update is added to the potential and the new potential \texttt{<interaction>.pot.new} is written. Additional post-processing of the potential can be performed in the \texttt{post\_add} step which is analogous to the \texttt{post\_update} step except for a potential instead of an update.

To summarize, we list all standard output files for each iterative step:

\begin{tabular}{ll}
\texttt{*.dist.new} & distribution functions of the current step \\
\texttt{*.dpot.new} & the final potential update, created by \texttt{calc\_update} \\
\texttt{*.dpot.<number>} & for each postupdate script, the \texttt{.dpot.new} is saved and a new one\\
&is created\\
\texttt{*.pot.cur} & the current potential used for the actual run\\
\texttt{*.pot.new} & the new potential after the add step \\
\texttt{*.pot.<number>} & same as \texttt{dpot.<number>} but for \texttt{post\_add}
\end{tabular}

If a sub-step fails during the iteration, additional information can be found in the log file. The name of the log file is specified in the steering \xml file.

\section{Restarting and continuing}
The interrupted or finished iterative process can be restarted either by extending a finished run or by restarting the interrupted run. When the script \prog{csg_inverse} is called, it automatically checks for a file called \texttt{done} in the current directory. If this file is found, the program assumes that the run is finished. To extend the run, simply increase \cgopt{inverse.iterations_max} in the settings file and remove the file called \texttt{done}. After that, \prog{csg_inverse} can be restarted, which will automatically recognize existing steps and continue after the last one.

If the iteration was interrupted, the script \prog{csg_inverse} might not be able to restart on its own. In this case, the easiest solution is to delete the last step and start again. The script will then repeat the last step and continue. However, this method is not always practical since sampling and analysis might be time-consuming and the run might have only crashed due to some inadequate post processing option. To avoid repeating the entire run, the script \prog{csg_inverse} creates a file with restart points and labels already completed steps such as simulation, analysis, etc. The file name is specified in the option \cgopt{inverse.restart_file}. If specific actions should be redone, one can simply remove the corresponding lines from this file. Note that a file \texttt{done} is also created in each folder for those steps which have been successfully finished.

\section{Customization}
Each sub-step of an iteration and all direct calls can be adjusted to the user needs. The internal part of the iterative framework is organized as follows: all scripts are called using two keywords
\begin{verbatim}
  csg_call key1 key2
\end{verbatim}
For example, \texttt{csg\_call update imc} calls the \texttt{update} script for the inverse Monte Carlo procedure. The corresponding keywords are listed in \sect{sec:csg_table} or can be output directly by calling
\begin{verbatim}
  csg_call --list
\end{verbatim}

It is advised not to change already implemented scripts. To customize a script or add a new one, copy the script to your own directory (set by \cgopt{inverse.scriptdir}) and redirect its call by creating your own \texttt{csg\_table} file in this directory which looks like this
\begin{verbatim}
  key1 key2 script1 options
  key3 key4 script2
\end{verbatim}
If the local keys are already in use, the existing call will be overloaded.

As an example, we will illustrate how to overload the script which calls the sampling package. 
The \prog{csg_inverse} script runs \progex{mdrun} from the \gromacs package only on one cpu. Our task will be to change the script so that \gromacs uses 8 cpus, which is basically the same as adding the mpi options in \cgopt{inverse.parallel}.

First we find out which script calls \progex{mdrun}:
\begin{verbatim}
  csg_call --list | grep gromacs
\end{verbatim}
The output should look as follows
\begin{verbatim}
  init gromacs initalize_gromacs.sh
  prepare gromacs prepare_gromacs.sh
  run gromacs run_gromacs.sh
  pressure gromacs calc_pressure_gromacs.sh
  rdf gromacs calc_rdf_gromacs.sh
  imc_stat gromacs imc_stat_generic.sh
  convert_potential gromacs potential_to_gromacs.sh
\end{verbatim}
the third line indicates the script we need. If the output of \prog{csg_call} is not clear, one can try to find the right script in \sect{sec:csg_table}. Alternatively, check the folder
\begin{verbatim}
  <csg-installation>/share/scripts/inverse
\end{verbatim}
for all available scripts. 

Analyzing the output of
\begin{verbatim}
  csg_call --cat run gromacs
\end{verbatim}
we can conclude that this is indeed the script we need:
%
\begin{verbatim}
  USES: run_or_exit mdrun
  run_or_exit mdrun
\end{verbatim}
Now we can create our own \texttt{SCRIPTDIR}, add a new script there, make it executable and overload the call of the script:
\begin{verbatim}
  mkdir -p SCRIPTDIR
  cp `csg_call --quiet --show run gromacs` SCRIPTDIR/my_run_gromacs.sh
  chmod 755 SCRIPTDIR/my_run_gromacs.sh
  echo "run gromacs my_run_gromacs.sh" >> SCRIPTDIR/csg_table
\end{verbatim}
Please note that \texttt{my\_run\_gromacs.sh} is the name of the script and \texttt{SCRIPTDIR} is the custom script directory, which can be a global or a local path.
Now we change the last line of \texttt{my\_run\_gromacs.sh} to:
\begin{verbatim}
  run_or_exit mpirun -np 8 mdrun
\end{verbatim}
This completes the customization. Do not forget to add \texttt{SCRIPTDIR} to \cgopt{inverse.scriptdir} in the setting \xml file (see \sect{sec:ref_options}).

You can check the new script by running:
\begin{verbatim}
  csg_call --scriptdir SCRIPTDIR --list
  csg_call --scriptdir SCRIPTDIR --run run gromacs
\end{verbatim}

Finally, do not forget to remove the license infomation and change the version number of the script.

