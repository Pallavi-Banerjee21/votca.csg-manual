\chapter{Iterative workflow control}
\label{sec:iterative_workflow}

Iterative workflow control is essential for the \ibi and \imc methods. Before using it, \texttt{CSGSHARE} variable must be set. \votca initialization script will do it for you (see sec.~\ref{sec:introduction} where it is explained how to source it.)

%\begin{figure}
\begin{wrapfigure}{ht}{7cm}  
\includegraphics[width=7cm]{functionality/fig/flowchart.eps}
  \caption{
    \label{fig:flowchart}
    Block-scheme of the workflow control for the iterative methods. The most time-consuming parts are marked in red.
  }
\end{wrapfigure}
%\end{figure}

The general idea of iterative workflow is sketched in fig.~\ref{fig:flowchart}. During the global initialization the initial guess for the coarse-grained potential is calculated from the reference function or converted from a given potential guess to the internal format. The actual iterative step starts with an iteration initialization. It searches for possible checkpoints and copies and converts files from the previous step and the base directory. Then the simulation run is prepared by converting potentials to the format required by the external sampling program and the actual sampling is performed. 

After sampling the phasespace, the potential update is calculated. Often the update requires postprocessing, such as smoothing, interpolation, extrapolation or fitting to an analytical form. 
Finally, the new potential is determined and postprocessed. If the iterative process continues, the next iterative step starts to initialize.

In what follows we describe how to setup the iterative coarse-graining, run the main script, continue the run, and add customized scripts. 

\section{Preparing the run}
To start the first iteration, one has to prepare the input for the sampling program. This means that all files for running a coarse-grained simulation must be present and described in a separate \xml file, in our case \texttt{settings.xml}. An exempt from this file is given below. The only exception is tabulated potentials, which will be created and updated by the script in the course of the iterative process.

The input files include: target distributions, initial guess (optional), list of interactions to be iteratively refined. As a target distribution, any table file can be given (e.g. \gromacs output from \texttt{g\_rdf}). The program automatically takes care to resample the table to the correct grid spacing, according to the options provided in \texttt{settings.xml}.

The initial guess is normally taken as a potential of mean force and is generated by Boltzmann-inversion of the corresponding distribution function. It is written in \texttt{step\_000/<name>.pot.new}. If you want to manually specify the initial guess for a specific interaction, write the potential table to a file called \texttt{<name>.pot.in} in the folder where you plan to run the iterative procedure.

A list of interactions to be iteratively refined has to be given in the options file. As an example, the \texttt{setting.xml} file for a propane is shown in listing~\ref{list:settings}. For more details,  see the full description of all options in ref.~\ref{sec:ref_options}.
\begin{figure}
\centering
\framebox{
\lstinputlisting{functionality/settings.xml}
}
\caption{\texttt{settings.xml} file specifies interactions to be refined, grid spacings, sampling engine, and the iterative method. The complete file can be found in the \texttt{propane/ibm} tutorial. 
\label{list:settings}
}
\end{figure}

\section{Starting the iterative process}
After all input files have been set up, the run can be started with
\begin{verbatim}
  csg_inverse settings.xml
\end{verbatim}

Each iteration is stored in a separate directory, named \texttt{step\_<iteration>}. \texttt{step\_000} is a special folder which contains the initial setup. For each new iteration, the files required to run the CG simulation (as specified in the config file) are copied to the current working directory. The updated potentials from the last steps \texttt{step\_<n-1>/<interaction>.pot.new} are also copied and used as the new working potentials \texttt{step\_<n>/<interaction>.pot.cur}.

After the run preparation, all potentials are converted to the format of the sampling program and the simulation starts. Once the sampling is finished, analysis programs generate new distributions (\texttt{<interaction>.dist.new}) and the updates potential updates, stored in \texttt{<interaction>.dpot.new}. 

Before adding the update to the old potential, it can be processed in the \texttt{post\_update} step. For each script that is specified in the postupdate, \texttt{<interaction>.dpot.new} is renamed  to \texttt{<interaction>.dpot.old}, stores it in \texttt{<interaction>.dpot.<a-number>}, and calls the processing script. Each processing script  uses the current potential update \texttt{<interaction>.dpot.cur} and writes the processed update to \texttt{<interaction>.dpot.new}. For example, pressure correction is implemented as a postupdate script within this framework.

After all postupdate scripts have been called, the update is added to the potential and the new potential \texttt{<interaction>.pot.new} is written. Additional post-processing of the potential can be performed at the \texttt{post\_add} step, analogous to the \texttt{post\_update} step but now for the potential instead of the update.

To summarize, we list all standard output files for each iterative step:

\begin{tabular}{ll}
\texttt{*.dist.new} & distribution functions of the current step \\
\texttt{*.dpot.new} & the final potential update, created by \texttt{calc\_update} \\
\texttt{*.dpot.<number>} & for each postupdate script, the \texttt{.dpot.new} is saved and a new one is created\\
\texttt{*.pot.cur} & the current potential, which the actual run was performed with \\
\texttt{*.pot.new} & the new potential after the add step \\
\texttt{*.pot.<number>} & same as \texttt{dpot.<number>} but for \texttt{post\_add}
\end{tabular}

If a sub-step fails during the iteration, additional information can be found in the log file. The name of the log file is specified in the steering \xml file.

\section{Restarting and continuing}
The interrupted or finished iterative process can be restarted either by extending a finished run or by restarting the interrupted run. When the script \prog{csg_inverse} is called, it automatically checks for a file called \texttt{done} in the current directory. If this file is found, the program assumes that the run is finished. To extend the run, simply increase \cgopt{inverse.iterations_max} in the settings file and remove the file called \texttt{done}. After that, \prog{csg_inverse} can be restarted, it will automatically recognize existing steps and continue after the last one.

If the iteration was interrupted, the script \prog{csg_inverse} might not be able to restart on its own. In this case, the easiest solution is to delete the last step and start again. The script will then repeat the last step and continue. However, this method is not always practical since sampling and analysis might be time-consuming and the run might have only crashed due to some inadequate post processing option. To avoid repeating the entire run, the script \prog{csg_inverse} creates a file with restart points, which labels already completed steps, e.~g. simulation, analysis, etc. The file name is specified in the option \cgopt{inverse.restart_file}. If specific actions should be redone, one can simply remove the corresponding lines from this file. Note that a file \texttt{done} is also created in each folder for those steps which have been successfully finished.

\section{Customization}
Each sub-step of an iteration and all direct calls can be adjusted to the user needs. The internal part of the iterative framework is organized as follows: all scripts are called using two keywords
\begin{verbatim}
  csg_call key1 key2
\end{verbatim}
For example, \texttt{csg\_call update imc} calls the \texttt{update} script for the inverse Monte Carlo procedure. The corresponding keywords ar listed in sec. \sect{sec:csg_table} or can be output directly by calling
\begin{verbatim}
  csg_call --list
\end{verbatim}

It is advised not to change already implemented scripts. To customize a script or add a new one, copy the script to your own directory (set by \cgopt{inverse.scriptdir}) and redirect its call by creating your own \texttt{csg\_table} file in this directory which looks like this
\begin{verbatim}
  key1 key2 script1 options
  key3 key4 script2
\end{verbatim}
If the local keys are already in use, the existing call will be overloaded.

As an example, we will illustrate how to overload the script which calls the sampling package. 
The \prog{csg_inverse} script runs \progex{mdrun} from the \gromacs package only on one cpu. Our task will be to change the script so that \gromacs uses 8 cpus. 

First we find out which script calls \progex{mdrun}:
\begin{verbatim}
  csg_call --list | grep gromacs
\end{verbatim}
The output should look as follows
\begin{verbatim}
  init gromacs initalize_gromacs.sh
  prepare gromacs prepare_gromacs.sh
  run gromacs run_gromacs.sh
  pressure gromacs calc_pressure_gromacs.sh
  rdf gromacs calc_rdf_gromacs.sh
  imc_stat gromacs imc_stat_generic.sh
  convert_potential gromacs potential_to_gromacs.sh
  functions gromacs functions_gromacs.sh
\end{verbatim}
the third line indicates the script we need. If the output of \prog{csg_call} is not clear, one can try to find the right script in \sect{sec:csg_table}. Alternatively, check the folder  \texttt{<csg-installation>/share/scripts/inverse} for all available scripts. 

Analyzing the output of
\begin{verbatim}
  csg_call --show run gromacs
\end{verbatim}
we can conclude that this is indeed the script we need:
%
\begin{verbatim}
  USES: run_or_exit mdrun
  run_or_exit mdrun
\end{verbatim}
Now we can create our own \texttt{SCRIPTDIR}, add a new script there, make it executable and overload the call of the script:
\begin{verbatim}
  mkdir -p SCRIPTDIR
  csg_call --show run gromacs > SCRIPTDIR/my_run_gromacs.sh
  chmod 755 SCRIPTDIR/my_run_gromacs.sh
  echo "run gromacs my_run_gromacs.sh" >> SCRIPTDIR/csg_table
\end{verbatim}
Please note that \texttt{my\_run\_gromacs.sh} is the name of the script and \texttt{SCRIPTDIR} is the custom script directory, which can be a global or a local path.
Now we change the last line of \texttt{my\_run\_gromacs.sh} to:
\begin{verbatim}
  run_or_exit mpirun -np 8 mdrun
\end{verbatim}
This completes the customization. Do not forget to add \texttt{SCRIPTDIR} to \cgopt{inverse.scriptdir} in the setting \xml file (see \sect{sec:ref_options}).

You can check the new script by running:
\begin{verbatim}
  csg_call --scriptdir SCRIPTDIR --list
  csg_call --scriptdir SCRIPTDIR --show run gromacs
\end{verbatim}

Finally, do not forget to remove the license infomation and change the version number of the script.

